
#include "font.h"

#define CHAR_COUNT 11

typedef struct {
  // Dimensions of each font character
  byte width;
  byte height;
  // 5 different positions, each an X/Y pair of pixel positions for the top-left corner of a character
  byte positions[10];
  // Pointer to character data in PROGMEM
  // Each character is the same length and size, and consists of a series of bits, in column first order, from top to bottom.
  // There are 2*CHAR_COUNT characters in here (twice the amount, because each character has a rotated form).
  const byte *data;
} Font;

// Font "00" (8x12)
const PROGMEM byte FONT_00_DATA[] = {
  0xfe, 0xf7, 0xff, 0x03, 0x3c, 0xc0, 0x03, 0x3c, 0xc0, 0xff, 0xef, 0x7f,
  0x0c, 0xec, 0xc0, 0x07, 0xfc, 0xff, 0xff, 0x0f, 0xc0, 0x00, 0x0c, 0xc0,
  0x06, 0x7c, 0xe0, 0x03, 0x3f, 0xf8, 0xc3, 0xfd, 0xcf, 0x7e, 0x0c, 0xc0,
  0x06, 0x76, 0xe0, 0x03, 0x3c, 0xc6, 0x63, 0x3c, 0xc6, 0xff, 0xef, 0x7f,
  0x80, 0x01, 0x1e, 0xf8, 0xe1, 0x19, 0x87, 0xf1, 0xff, 0xff, 0x0f, 0x18,
  0x3f, 0xfc, 0xc3, 0x33, 0x3c, 0xc3, 0x33, 0x3c, 0xc7, 0xe3, 0x0f, 0x7c,
  0xfc, 0xe7, 0xff, 0x67, 0x3c, 0xc6, 0x63, 0x3c, 0xc6, 0xe3, 0x0f, 0x7c,
  0x03, 0x30, 0xc0, 0x03, 0x3f, 0x3c, 0xf3, 0xf0, 0x03, 0x0f, 0x30, 0x00,
  0x9e, 0xf7, 0xff, 0x63, 0x3c, 0xc6, 0x63, 0x3c, 0xc6, 0xff, 0xef, 0x79,
  0x3e, 0xfc, 0xc7, 0x63, 0x3c, 0xc6, 0x63, 0x3e, 0x76, 0xfe, 0xc3, 0x1f,
  0x00, 0x00, 0x00, 0x00, 0x80, 0x31, 0x18, 0x03, 0x00, 0x00, 0x00, 0x00,
  0x7e, 0xff, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0x7e,
  0xff, 0xff, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1b, 0x1f, 0x1e, 0x1c,
  0xff, 0xff, 0x0e, 0x1c, 0x38, 0x70, 0x60, 0x60, 0x60, 0x63, 0x7f, 0x3e,
  0x7e, 0xff, 0xc3, 0xc0, 0xc0, 0xf8, 0xf8, 0xc0, 0xc0, 0xc3, 0xff, 0x7e,
  0x60, 0x60, 0x60, 0xff, 0xff, 0x66, 0x66, 0x6c, 0x6c, 0x78, 0x78, 0x70,
  0x7f, 0xff, 0xc0, 0xc0, 0xc0, 0xe0, 0x7f, 0x3f, 0x03, 0x03, 0x7f, 0x7f,
  0x7e, 0xff, 0xc3, 0xc3, 0xc3, 0xff, 0x7f, 0x03, 0x03, 0x07, 0x7e, 0x7c,
  0x06, 0x06, 0x0c, 0x0c, 0x18, 0x18, 0x30, 0x30, 0x60, 0x60, 0xff, 0xff,
  0x7e, 0xff, 0xc3, 0xc3, 0xc3, 0x7e, 0x7e, 0xc3, 0xc3, 0xc3, 0xff, 0x7e,
  0x1f, 0x3f, 0x70, 0xe0, 0xc0, 0xfe, 0xff, 0xc3, 0xc3, 0xc3, 0x7f, 0x3e,
  0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
};

// Font "45" (14x14)
const PROGMEM byte FONT_45_DATA[] = {
  0x00, 0x00, 0x1c, 0x80, 0x0f, 0x70, 0x07, 0x8e, 0x83, 0xc1, 0xe1, 0xe0, 0x70, 0x70, 0x38, 0x18, 0x1c, 0x07, 0xee, 0x00, 0x1f, 0x80, 0x03, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x80, 0x07, 0xf0, 0x01, 0x38, 0x00, 0x1c, 0x00, 0x0e, 0x00, 0x47, 0x80, 0x3b, 0xc0, 0x07, 0xe0, 0x00, 0x1c, 0x80, 0x03, 0x40, 0x00,
  0x00, 0x00, 0x3c, 0x80, 0x0f, 0x70, 0x00, 0x0c, 0x00, 0x03, 0xc0, 0x01, 0xe0, 0xff, 0xf0, 0x3f, 0x00, 0x07, 0xe0, 0x00, 0x1c, 0x80, 0x03, 0x40, 0x00,
  0x00, 0x00, 0x1c, 0x80, 0x07, 0x70, 0x00, 0x0e, 0x80, 0x11, 0xe0, 0x0e, 0xf0, 0x61, 0x38, 0x18, 0x1c, 0x07, 0xee, 0x00, 0x1f, 0x80, 0x03, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x80, 0x03, 0xf0, 0x07, 0xfe, 0x0f, 0xe7, 0x87, 0xe3, 0xc0, 0x1d, 0xe0, 0x03, 0x70, 0x00, 0x3e, 0x00, 0x1d, 0x00, 0x02, 0x00, 0x00,
  0x00, 0x00, 0x0c, 0x80, 0x07, 0xf0, 0x03, 0xce, 0xc1, 0xe1, 0x20, 0x1c, 0x80, 0x43, 0x60, 0x38, 0x18, 0x07, 0xee, 0x00, 0x1f, 0x80, 0x03, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x80, 0x0f, 0xf0, 0x07, 0x8e, 0xc3, 0xe1, 0x21, 0xfc, 0x80, 0x73, 0x60, 0x18, 0x18, 0x07, 0xee, 0x00, 0x1f, 0x80, 0x03, 0x00, 0x00,
  0x20, 0x00, 0x1c, 0x80, 0x03, 0x70, 0x00, 0x0e, 0xc0, 0x01, 0xf0, 0x00, 0xfc, 0x01, 0xf8, 0x03, 0xf0, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x1c, 0x80, 0x0f, 0x70, 0x07, 0x8e, 0x81, 0xe1, 0xe1, 0xfc, 0xf0, 0x73, 0x78, 0x18, 0x18, 0x07, 0xee, 0x00, 0x1f, 0x80, 0x03, 0x00, 0x00,
  0x00, 0x00, 0x1c, 0x80, 0x0f, 0x70, 0x07, 0x8e, 0x81, 0x71, 0xe0, 0x0e, 0xf0, 0x41, 0x38, 0x38, 0x1c, 0x07, 0xfe, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xe0, 0x00, 0x7c, 0x80, 0x3b, 0x70, 0x1c, 0x0e, 0xc6, 0xc1, 0x39, 0x38, 0x06, 0x87, 0xe3, 0xc0, 0x1d, 0xe0, 0x03, 0x70, 0x00, 0x00, 0x00,
  0x00, 0x01, 0xe0, 0x00, 0x70, 0x00, 0x38, 0x00, 0x1f, 0xe0, 0x0e, 0x1c, 0xb1, 0x03, 0x7c, 0x00, 0x0f, 0xc0, 0x01, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x80, 0x01, 0xe0, 0x00, 0x78, 0x00, 0x3e, 0x80, 0x1d, 0x60, 0x6e, 0x18, 0x19, 0x06, 0x86, 0x81, 0x73, 0xc0, 0x0f, 0xe0, 0x01, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xe0, 0x00, 0x78, 0x00, 0x38, 0x00, 0x1c, 0x00, 0x06, 0xc4, 0x99, 0x3b, 0xc6, 0x87, 0xe3, 0xc0, 0x1d, 0xe0, 0x03, 0x70, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x08, 0x00, 0x07, 0xc0, 0x23, 0xf0, 0x1d, 0xee, 0x83, 0x73, 0x60, 0x3e, 0xdc, 0x05, 0x3f, 0xc0, 0x07, 0xe0, 0x00, 0x10, 0x00, 0x00, 0x00,
  0x00, 0x01, 0xe0, 0x00, 0x70, 0x00, 0x38, 0x20, 0x1c, 0x1c, 0x86, 0xcf, 0x71, 0x3f, 0x8e, 0x87, 0x03, 0xc0, 0x01, 0xe0, 0x00, 0x70, 0x00, 0x08, 0x00,
  0x00, 0x00, 0xe0, 0x00, 0x7c, 0x80, 0x3b, 0x70, 0x1c, 0x1e, 0xc6, 0xcf, 0x31, 0x3f, 0x8c, 0x07, 0x03, 0xc0, 0x01, 0xe0, 0x00, 0x70, 0x00, 0x08, 0x00,
  0x00, 0x00, 0x80, 0x00, 0x60, 0x00, 0x18, 0x00, 0x07, 0xc0, 0x00, 0x30, 0x08, 0x0e, 0x87, 0x81, 0x63, 0xc0, 0x1d, 0xe0, 0x03, 0xf0, 0x00, 0x38, 0x00,
  0x00, 0x00, 0xe0, 0x00, 0x7c, 0x80, 0x3b, 0x60, 0x1c, 0x1e, 0xc6, 0xcf, 0x39, 0x3f, 0x86, 0x87, 0x63, 0xc0, 0x1d, 0xe0, 0x03, 0x70, 0x00, 0x00, 0x00,
  0x00, 0x01, 0xe0, 0x00, 0x70, 0x00, 0x38, 0x00, 0x0c, 0x0e, 0xc3, 0xc7, 0xb8, 0x3b, 0xc6, 0x87, 0xe3, 0xc0, 0x1d, 0xe0, 0x03, 0x70, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const PROGMEM Font FONT_00 = {
  // Width, height
  8, 12,
  {
    // Position 0
    3, 18,
    // Position 1
    13, 18,
    // Position 2
    20, 18,
    // Position 3
    27, 18,
    // Position 4
    37, 18,
  },
  // Data
  // Characters: "0123456789:" (11*2 characters)
  // Character dimensions: 8x12 (12 bytes each)
  FONT_00_DATA,
};

const PROGMEM Font FONT_45 = {
  // Width, height
  14, 14,
  {
    // Position 0
    5, 29,
    // Position 1
    12, 22,
    // Position 2
    17, 17,
    // Position 3
    23, 11,
    // Position 4
    30, 4,
  },
  // Data
  // Characters: "0123456789:" (11*2 characters)
  // Character dimensions: 14x14 (25 bytes each)
  FONT_45_DATA,
};

#define BUFFER_X 40
#define BUFFER_PAGEY 0
#define BUFFER_WIDTH 48
#define BUFFER_PAGES 6

static byte buffer_mem[2 * BUFFER_WIDTH * BUFFER_PAGES];
static byte *front_buffer = buffer_mem;

void scr_clear() {
  for (int i = 0; i < BUFFER_WIDTH * BUFFER_PAGES; i += 1) {
    front_buffer[i] = 0;
  }
}

void draw_upright(int width, int height, int base_x, int base_y, const byte *data) {
  //Write data
  int min_page = base_y / 8;
  int page_offset = base_y % 8;
  int max_page = (base_y + height + 7) / 8 - 1;
  for (int page = min_page; page <= max_page; page += 1) {
    byte mask = 0xff;
    if (page == min_page) {
      mask <<= page_offset;
    } else if (page == max_page) {
      mask >>= (8 - (base_y + height) % 8) % 8;
    }
    for (int dx = 0; dx < width; dx += 1) {
      int offset = (page - min_page) * 8 - page_offset + dx * height;
      int byte_offset = (offset + 8) / 8 - 1;
      int bit_offset = (offset + 8) % 8;
      byte page_col = data[byte_offset] >> bit_offset;
      if (bit_offset > 0) {
        page_col |= data[byte_offset + 1] << (8 - bit_offset);
      }
      front_buffer[page * BUFFER_WIDTH + base_x + dx] |= page_col & mask;
    }
  }
}

void draw_upsidedown(int width, int height, int base_x, int base_y, const byte *data) {
  //Write data
  int min_page = base_y / 8;
  int page_offset = base_y % 8;
  int max_page = (base_y + height + 7) / 8 - 1;
  for (int page = min_page; page <= max_page; page += 1) {
    byte mask = 0xff;
    if (page == min_page) {
      mask <<= page_offset;
    } else if (page == max_page) {
      mask >>= (8 - (base_y + height) % 8) % 8;
    }
    for (int dx = 0; dx < width; dx += 1) {
      int offset = width * height + page_offset - (page - min_page) * 8 - dx * height;
      int byte_offset = (offset + 8) / 8 - 1;
      int bit_offset = (offset + 8) % 8;
      byte page_col = data[byte_offset - 1] >> bit_offset;
      if (bit_offset > 0) {
        page_col |= data[byte_offset] << (8 - bit_offset);
      }
      page_col = reverse_byte(page_col);
      front_buffer[page * BUFFER_WIDTH + base_x + dx] |= page_col & mask;
    }
  }
}

void scr_draw(int orient, int pos, int ch) {
  //Pick rotation based on `orient`
  const Font *font_ptr;
  int rotate;
  switch (orient) {
    case ORIENT_000:
      font_ptr = &FONT_00;
      rotate = 0;
      break;
    case ORIENT_072:
      font_ptr = &FONT_00;
      rotate = 1;
      break;
    case ORIENT_144:
      font_ptr = &FONT_45;
      rotate = 2;
      break;
    case ORIENT_216:
      font_ptr = &FONT_45;
      rotate = 3;
      break;
    case ORIENT_288:
      font_ptr = &FONT_00;
      rotate = 3;
      break;
    default:
      return;
  }
  Font font;
  memcpy_P(&font, font_ptr, sizeof(Font));

  //Get position
  int base_x = font.positions[pos * 2];
  int base_y = font.positions[pos * 2 + 1];

  //Get character data
  #define MAX_CAP 64
  byte data[MAX_CAP];
  int stride = (((int)font.width) * font.height + 7) / 8;
  if (stride > MAX_CAP) {
    Serial.println("Font size overflows char data capacity!");
    for (;;) {}
  }
  #undef MAX_CAP
  int char_idx;
  int width;
  int height;
  int x;
  int y;
  if ((rotate & 0x1) == 0) {
    //Do not rotate 90 degrees
    width = font.width;
    height = font.height;
    x = base_x;
    y = base_y;
    char_idx = ch;
  } else {
    //Rotate 90 degrees
    width = font.height;
    height = font.width;
    x = BUFFER_WIDTH / 2 - (base_y - BUFFER_PAGES * 4) - width;
    y = BUFFER_PAGES * 4 + (base_x - BUFFER_WIDTH / 2);
    char_idx = ch + CHAR_COUNT;
  }
  memcpy_P(&data, font.data + char_idx * stride, stride);

  //Draw differently depending on orientation
  if ((rotate & 0x2) == 0) {
    draw_upright(width, height, x, y, data);
  } else {
    draw_upsidedown(width, height, BUFFER_WIDTH - x - width, BUFFER_PAGES * 8 - y - height, data);
  }
}

void scr_show() {
  //Find backbuffer
  byte *backbuf;
  if (front_buffer == buffer_mem) {
    backbuf = buffer_mem + BUFFER_WIDTH * BUFFER_PAGES;
  } else {
    backbuf = buffer_mem;
  }
  //Update OLED
  for (int page = 0; page < BUFFER_PAGES; page += 1) {
    //Find the last modified column
    int modified_up_to = 0;
    for (int x = BUFFER_WIDTH - 1; x >= 0; x -= 1) {
      int idx = page * BUFFER_WIDTH + x;
      if (front_buffer[idx] != backbuf[idx]) {
        modified_up_to = x + 1;
        break;
      }
    }
    bool started = false;
    for (int x = 0; x < modified_up_to; x += 1) {
      int idx = page * BUFFER_WIDTH + x;
      byte page_col = front_buffer[idx];
      if (!started) {
        if (page_col == backbuf[idx]) {
          continue;
        }
        oled.setCursor(BUFFER_X + x, BUFFER_PAGEY + page);
        oled.startData();
        started = true;
      }
      oled.sendData(page_col);
    }
    if (started) {
      oled.endData();
    }
  }
  //Swap buffer
  front_buffer = backbuf;
}
